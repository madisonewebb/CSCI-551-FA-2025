// GENERATED by ChatGPT 4.0 from OpenAI
//
// Prompted by Sam Siewert

#include <stdio.h>
#include <stdlib.h>

// Define a Pixel as an unsigned char since PGM only deals with grayscale values (0-255)
typedef unsigned char Pixel;

// Image structure to hold the width, height, and pixel data of a PGM image
typedef struct {
    int width, height;
    Pixel *data;
} Image;

// Function to skip comments in a PGM file. PGM files might have comments starting with #
void skip_comments(FILE *fp) {
    char ch = fgetc(fp);
    while (ch == '#') {
        while (fgetc(fp) != '\n');  // Skip the entire line of comment
        ch = fgetc(fp);
    }
    ungetc(ch, fp);  // Push back the read character to the file stream
}

// Function to load a PGM file given its filename
Image *load_pgm(const char *filename) {
    FILE *file = fopen(filename, "rb");  // Open the file in binary read mode
    if (!file) {
        perror("Failed to open file");
        exit(1);
    }

    char type[3];
    fscanf(file, "%2s", type);  // Read the magic number (e.g., P5)
    fgetc(file);  // Consume the newline after the magic number

    if (type[0] != 'P' || type[1] != '5') {
        fprintf(stderr, "Only P5 format is supported.\n");
        exit(1);
    }

    skip_comments(file);  // Skip any comments in the PGM file

    Image *img = (Image *)malloc(sizeof(Image));
    int max_value;

    // Read the image dimensions and maximum pixel value
    fscanf(file, "%d %d", &img->width, &img->height);
    skip_comments(file);
    fscanf(file, "%d", &max_value);
    fgetc(file);  // Consume the newline after max_value

    // Allocate memory for pixel data
    img->data = (Pixel *)malloc(img->width * img->height * sizeof(Pixel));
    
    // Read pixel data from the file into the allocated memory
    fread(img->data, sizeof(Pixel), img->width * img->height, file);
    
    fclose(file);  // Close the file
    return img;    // Return the loaded image
}

// Function to save an Image structure as a PGM file
void save_pgm(const char *filename, Image *img) {
    FILE *file = fopen(filename, "wb");  // Open the file in binary write mode
    if (!file) {
        perror("Failed to open file");
        exit(1);
    }

    // Write the PGM header
    fprintf(file, "P5\n%d %d\n255\n", img->width, img->height);
    
    // Write the pixel data to the file
    fwrite(img->data, sizeof(Pixel), img->width * img->height, file);
    
    fclose(file);  // Close the file
}

int main(int argc, char *argv[]) {
    // Check for correct number of command line arguments
    if (argc != 4) {
        fprintf(stderr, "Usage: %s <larger_image.pgm> <smaller_image.pgm> <output_image.pgm>\n", argv[0]);
        return 1;
    }

    // Load the two PGM images from the provided file paths
    Image *img1 = load_pgm(argv[1]);
    Image *img2 = load_pgm(argv[2]);

    // Check if the first image is indeed larger than the second
    if (img1->width < img2->width || img1->height < img2->height) {
        fprintf(stderr, "The first image should be larger than the second image.\n");
        return 1;
    }

    // Calculate the starting position to embed the smaller image into the center of the larger image
    int offsetX = (img1->width - img2->width) / 2;
    int offsetY = (img1->height - img2->height) / 2;

    // Embed the smaller image into the larger one
    for (int i = 0; i < img2->height; i++) {
        for (int j = 0; j < img2->width; j++) {
            img1->data[(i + offsetY) * img1->width + (j + offsetX)] = img2->data[i * img2->width + j];
        }
    }

    // Save the merged image to the specified output file
    save_pgm(argv[3], img1);

    // Free allocated memory for both images
    free(img1->data);
    free(img1);
    free(img2->data);
    free(img2);

    return 0;  // End of program
}
