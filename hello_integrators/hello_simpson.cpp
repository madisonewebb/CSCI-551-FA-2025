// First cut generated by ChatGPT 4.0 (ChatGPT 3.5 works too), but refactored by Sam Siewert
//
// Fixes include:
//
// 1) Style
// 2) Step size
// 3) Print out for 15 digits of precision
// 4) Commenting - ChatGPT was used with my comments in a blended fashion (I commented first, then
//    asked ChatGPT to improve, but it really offered little improvement - not good at commenting).
//
// Note that ChatGPT is useful for fix syntax if you know what you want.  It's pretty lowsy at generating
// friendly comments that explain the theory (math) behind each line of code.
//

#include <iostream>
#include <cmath>

//#define RANGE (M_PI/2.0)
#define RANGE (M_PI)
#define STEPS (1000000)

double function_to_integrate(double x);

int thread_count=1;

//////////////////////////////////////////////////////////////////////////////
// Computes the definite integral of a given function using Simpson's rule. //
//                                                                          //
// @param a         The lower bound of integration.                         //
// @param b         The upper bound of integration.                         //
// @param n         The number of steps to use in the approximation.        //
//                                                                          //
// @return          The approximate value of the definite integral.         //
//////////////////////////////////////////////////////////////////////////////
double simpsons_rule(double a, double b, int n) 
{
    double h = (b - a) / n;
    double sum = 0.0;

#pragma omp parallel for num_threads(thread_count) reduction(+:sum)
    for (int idx = 0; idx <= n; idx++) 
    {
        double x = a + idx * h;
        double fx = function_to_integrate(x);

        // See https://en.wikipedia.org/wiki/Simpson's_rule for more information
        //
        // 1) on the first we evaluate f(a) and on the last we evaluate f(b)
        // 2) for steps between we alternate between (4/3)f(a+b) and (2/3)f(a+b)
        // 3) at the end we return h times the weighted sum of all the 1/3, 4/3, 2/3 summation
        //    terms.
        //
        if (idx == 0 || idx == n) 
        {
            sum += fx;
        } 

        // Alternating 4/3 and 2/3 weighting for points between f(a) and f(b)
        else if (idx % 2 == 1) 
        {
            sum += 4.0 * fx;
        } 
        else 
        {
            sum += 2.0 * fx;
        }
    }

    // h=(b-a)/n, sum= [f(a) + f(b)] + (4 or 2)*f(a+b), all multipied by 1/3
    return h * sum / 3.0;
}


int main(int argc, char* argv[]) 
{
    double a = 0.0;
    double b = RANGE;

    if(argc == 2)
    {
        sscanf(argv[1], "%d", &thread_count);
        printf("Will run with: thread_count=%d\n", thread_count);
    }
    else
    {
        printf("Will run with default: thread_count=%d\n", thread_count);
    }

    int n = STEPS;
    double result = simpsons_rule(a, b, n);

    std::cout.precision(15);
    std::cout << "The integral of f(x) from 0.0 to " << RANGE << " with steps=" << n << " is " << result << std::endl;

    return 0;
}


double function_to_integrate(double x)
{
    return (sin(x));
}
